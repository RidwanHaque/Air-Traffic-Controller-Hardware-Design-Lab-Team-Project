# Air Traffic Control Hardware Programming Project (SCOMP)

This project implements a simple 16‑bit processor system (SCOMP) and peripherals on an Intel/Altera MAX 10 FPGA using Intel Quartus. It was developed for an air‑traffic‑control–themed hardware programming course project and demonstrates a complete hardware/software stack: CPU, timer, digital I/O, LED controller, seven‑segment display driver, and clock‑generation logic.

## Project Overview

The top‑level design is a Quartus Block Diagram File (`SCOMP_System.bdf`) that instantiates the SCOMP CPU, clock‑generation blocks, I/O decoder, and multiple peripherals (switch input, timer, hexadecimal display, LED controller). The CPU executes an assembled program stored in on‑chip memory (initialized from a `.mif` file) to interact with the hardware in real time.

Core features:

- Custom 16‑bit SCOMP CPU with interrupt support and a rich instruction set (load/store, arithmetic/logic, branches, I/O, and interrupts).
- Multiple peripherals mapped into an I/O address space using a centralized I/O decoder.
- LED controller with pattern generation and PWM brightness control.
- Multi‑rate clock generation from a single PLL reference clock and a VHDL clock divider.
- Timer peripheral, digital input/output modules, and seven‑segment display driver.

## Repository Structure

Key files and directories (names may vary slightly):

- `SCOMP_System.bdf`  
  Top‑level schematic for the system. Instantiates the CPU, clocking blocks, I/O decoder, peripherals, and board‑level I/O pins.

- `SCOMP.vhd`  
  VHDL implementation of the SCOMP 16‑bit processor, including:
  - Fetch–decode–execute state machine.
  - Unified instruction/data memory via `altsyncram` with initialization from `testFinal.mif`.
  - I/O bus interface (`IO_ADDR`, `IO_DATA`, `IO_WRITE`, `IO_CYCLE`).
  - Interrupt controller with maskable interrupt lines and return‑from‑interrupt support.

- `clk_div.vhd`  
  Clock‑divider module that takes a 12 MHz input (`clock_12MHz`) and generates several lower‑frequency clocks (100 kHz, 10 kHz, 100 Hz, 32 Hz, 10 Hz, 4 Hz) using integer counters and toggling internal clock signals.

- `PLL_main.*`  
  Quartus PLL IP core that generates the main internal clock(s) from the board reference clock. The `.qip`, `.cmp`, and related files are auto‑generated by the IP wizard.

- `DIG_IN.vhd`  
  Digital input peripheral that samples a 16‑bit input vector and exposes it on the shared I/O data bus using an `lpm_bustri` tri‑state driver. Data is latched on the rising edge of `CS` when `READ_EN` is asserted.

- `DIG_OUT.vhd`  
  Digital output peripheral that latches a 16‑bit value from the I/O data bus on the rising edge of `CS` when `WRITE_EN` is high. Provides a synchronous reset and is typically used to drive LEDs or other discrete outputs.

- `HEX_DISP.vhd`  
  Hex‑to‑7‑segment decoder:
  - Latches a 4‑bit `hex_val` on the rising edge of `cs`.
  - Supports a `free` input to choose between latched or “free‑running” display.
  - Drives a 7‑segment pattern for hexadecimal digits `0`–`F`.

- `IO_DECODER.vhd`  
  I/O decoder that maps 11‑bit `IO_ADDR` and `IO_CYCLE` into individual chip‑select enables:
  - Switch input enable
  - Timer enable
  - HEX0 and HEX1 display enables
  - LED controller enable

- `LEDController.vhd`  
  Custom LED peripheral for pattern and brightness control:
  - On a write (`CS` rising with `WRITE_EN = '1'`), interprets bits of `IO_DATA`:
    - Bit 15: mode select (direct vs. brightness/pattern mode).
    - Bits 14–11: brightness level encoded as a 4‑bit value.
    - Bit 10: pattern source (user pattern vs. predefined pattern set).
    - Bits 9–0: LED pattern or pattern selector.
  - Uses a clocked process with a counter and PWM‑style duty cycles to approximate multiple brightness levels while applying the chosen LED pattern.

- `TIMER.vhd`  
  Timer peripheral:
  - 16‑bit up‑counter driven by `CLOCK`.
  - Counter resets on active‑low reset or on a write to the timer address (`CS` and `IO_WRITE` both high).
  - Uses `lpm_bustri` to present a stable snapshot (`IO_COUNT`) of the count value on the I/O data bus during reads.

- `DIG_IN.bdf`, `HEX_DISP_6.bdf`, and other `.bdf` files  
  Schematic implementations or wrappers tying VHDL blocks to the top‑level system.

- `db/`, `incremental_db/`, simulation subdirectories, and other generated files  
  Build artifacts created by Quartus; these typically should not be committed or edited manually.

## Building and Programming

1. **Open the project in Quartus**  
   - Launch Intel Quartus (or Quartus Prime Standard).  
   - Open the project file (`.qpf` / `.qsf`) in this directory.  

2. **Compile the design**  
   - Run `Analysis & Synthesis`, then `Fit`, then `Assembler` from the Quartus GUI, or use the full compile flow.  
   - Ensure the correct target device (MAX 10 on the associated DE board) is selected in the project settings.

3. **Program the FPGA**  
   - Open the Quartus Programmer.  
   - Select your USB‑Blaster or equivalent JTAG cable.  
   - Add the compiled `.sof` file and program the FPGA.  

4. **Run the SCOMP program**  
   - The on‑chip memory is initialized from `testFinal.mif`.  
   - After configuration, the SCOMP CPU begins executing from address 0, interacting with the peripherals through the defined I/O addresses.

## I/O Map (High‑Level)

The I/O decoder maps addresses to peripherals (exact addresses come from `IO_DECODER.vhd`):

- `0x000` – Switch input peripheral (`DIG_IN`)  
- `0x002` – Timer peripheral (`TIMER`)  
- `0x004` – HEX0 display (`HEX_DISP`)  
- `0x005` – HEX1 display (`HEX_DISP`)  
- `0x020` – LED controller (`LEDController`)

These addresses are accessed by SCOMP instructions `in`, `out`, and related I/O operations.

## Development and Extension

Ideas for extending or adapting the project:

- Modify `LEDController.vhd` to add more patterns, different PWM resolutions, or support for RGB LEDs.
- Change `clk_div.vhd` constants to accommodate different input frequencies or custom timing requirements.
- Extend SCOMP’s instruction set or memory size by modifying `SCOMP.vhd` and the associated microarchitecture.
- Add new peripherals (e.g., UART, additional timers, or more displays) and assign them unused I/O addresses in `IO_DECODER.vhd`.

## Git and Version Control Notes

Recommended `.gitignore` entries for Quartus projects:

